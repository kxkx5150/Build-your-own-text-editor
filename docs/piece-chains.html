<html><head>
    <meta charset="utf-8">

<title>Piece Chains - Catch22</title>
<meta name="description" content="OK so I lied about getting the syntax-highlighting implemented this time around. I got bogged down in “regular expression hell” and needed something else to concentrate on. So during the summer period I’ve instead been slowly implementing Neatpad’s text-editing capability. As I hinted at in the very first installment of this tutorial series, I have decided to follow the “Piece Table” design. The aim of this tutorial will be to discuss the rationale behind this decision and also highlight some (but not all) of the implementation details. Note that I will not be discussing issues related to the editing of Unicode text (this will come in the next tutorial). Instead we will look at the design of the piece-table from a low-level perspective, independent of any Unicode concerns.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Catch22">
<meta property="og:title" content="Piece Chains">
<meta property="og:url" content="piece-chains">


  <meta property="og:description" content="OK so I lied about getting the syntax-highlighting implemented this time around. I got bogged down in “regular expression hell” and needed something else to concentrate on. So during the summer period I’ve instead been slowly implementing Neatpad’s text-editing capability. As I hinted at in the very first installment of this tutorial series, I have decided to follow the “Piece Table” design. The aim of this tutorial will be to discuss the rationale behind this decision and also highlight some (but not all) of the implementation details. Note that I will not be discussing issues related to the editing of Unicode text (this will come in the next tutorial). Instead we will look at the design of the piece-table from a low-level perspective, independent of any Unicode concerns.">







  <meta property="article:published_time" content="2006-09-12T00:00:00+00:00">






<style type="text/css">svg:not(:root).svg-inline--fa{overflow:visible}.svg-inline--fa{display:inline-block;font-size:inherit;height:1em;overflow:visible;vertical-align:-.125em}.svg-inline--fa.fa-lg{vertical-align:-.225em}.svg-inline--fa.fa-w-1{width:.0625em}.svg-inline--fa.fa-w-2{width:.125em}.svg-inline--fa.fa-w-3{width:.1875em}.svg-inline--fa.fa-w-4{width:.25em}.svg-inline--fa.fa-w-5{width:.3125em}.svg-inline--fa.fa-w-6{width:.375em}.svg-inline--fa.fa-w-7{width:.4375em}.svg-inline--fa.fa-w-8{width:.5em}.svg-inline--fa.fa-w-9{width:.5625em}.svg-inline--fa.fa-w-10{width:.625em}.svg-inline--fa.fa-w-11{width:.6875em}.svg-inline--fa.fa-w-12{width:.75em}.svg-inline--fa.fa-w-13{width:.8125em}.svg-inline--fa.fa-w-14{width:.875em}.svg-inline--fa.fa-w-15{width:.9375em}.svg-inline--fa.fa-w-16{width:1em}.svg-inline--fa.fa-w-17{width:1.0625em}.svg-inline--fa.fa-w-18{width:1.125em}.svg-inline--fa.fa-w-19{width:1.1875em}.svg-inline--fa.fa-w-20{width:1.25em}.svg-inline--fa.fa-pull-left{margin-right:.3em;width:auto}.svg-inline--fa.fa-pull-right{margin-left:.3em;width:auto}.svg-inline--fa.fa-border{height:1.5em}.svg-inline--fa.fa-li{width:2em}.svg-inline--fa.fa-fw{width:1.25em}.fa-layers svg.svg-inline--fa{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.fa-layers{display:inline-block;height:1em;position:relative;text-align:center;vertical-align:-.125em;width:1em}.fa-layers svg.svg-inline--fa{-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter,.fa-layers-text{display:inline-block;position:absolute;text-align:center}.fa-layers-text{left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);-webkit-transform-origin:center center;transform-origin:center center}.fa-layers-counter{background-color:#ff253a;border-radius:1em;-webkit-box-sizing:border-box;box-sizing:border-box;color:#fff;height:1.5em;line-height:1;max-width:5em;min-width:1.5em;overflow:hidden;padding:.25em;right:0;text-overflow:ellipsis;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-bottom-right{bottom:0;right:0;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom right;transform-origin:bottom right}.fa-layers-bottom-left{bottom:0;left:0;right:auto;top:auto;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:bottom left;transform-origin:bottom left}.fa-layers-top-right{right:0;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top right;transform-origin:top right}.fa-layers-top-left{left:0;right:auto;top:0;-webkit-transform:scale(.25);transform:scale(.25);-webkit-transform-origin:top left;transform-origin:top left}.fa-lg{font-size:1.3333333333em;line-height:.75em;vertical-align:-.0667em}.fa-xs{font-size:.75em}.fa-sm{font-size:.875em}.fa-1x{font-size:1em}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-6x{font-size:6em}.fa-7x{font-size:7em}.fa-8x{font-size:8em}.fa-9x{font-size:9em}.fa-10x{font-size:10em}.fa-fw{text-align:center;width:1.25em}.fa-ul{list-style-type:none;margin-left:2.5em;padding-left:0}.fa-ul>li{position:relative}.fa-li{left:-2em;position:absolute;text-align:center;width:2em;line-height:inherit}.fa-border{border:solid .08em #eee;border-radius:.1em;padding:.2em .25em .15em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left,.fab.fa-pull-left,.fal.fa-pull-left,.far.fa-pull-left,.fas.fa-pull-left{margin-right:.3em}.fa.fa-pull-right,.fab.fa-pull-right,.fal.fa-pull-right,.far.fa-pull-right,.fas.fa-pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.fa-rotate-90{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-webkit-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-webkit-transform:scale(1,-1);transform:scale(1,-1)}.fa-flip-horizontal.fa-flip-vertical{-webkit-transform:scale(-1,-1);transform:scale(-1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{-webkit-filter:none;filter:none}.fa-stack{display:inline-block;height:2em;position:relative;width:2.5em}.fa-stack-1x,.fa-stack-2x{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0}.svg-inline--fa.fa-stack-1x{height:1em;width:1.25em}.svg-inline--fa.fa-stack-2x{height:2em;width:2.5em}.fa-inverse{color:#fff}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.sr-only-focusable:active,.sr-only-focusable:focus{clip:auto;height:auto;margin:0;overflow:visible;position:static;width:auto}</style><link rel="canonical" href="piece-chains.html">













<!-- end _includes/seo.html -->


<link href="../../feed.xml" type="application/atom+xml" rel="alternate" title="Catch22 Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  <style id="fit-vids-style">.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}</style></head>

  <body class="layout--tutorial wide" style="margin-bottom: 171.375px;">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="../../index.html">Catch22</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="../../blog/index.html">Blog</a>
            </li><li class="masthead__menu-item">
              <a href="../../software/index.html">Software</a>
            </li><li class="masthead__menu-item">
              <a href="../../tuts/index.html">Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="../../about/index.html">About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button" count="0" style="">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope="" itemtype="../../../schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope="" itemtype="../../../schema.org/ListItem">
          <a href="../../index.html" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1">
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope="" itemtype="../../../schema.org/ListItem">
          <a href="../../tuts.html" itemprop="item"><span itemprop="name">Tuts</span></a>
          <meta itemprop="position" content="2">
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        
        <li itemprop="itemListElement" itemscope="" itemtype="../../../schema.org/ListItem">
          <a href="../../tuts/neatpad.html" itemprop="item"><span itemprop="name">Neatpad</span></a>
          <meta itemprop="position" content="3">
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        <li class="current">Piece Chains</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      
  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="assets/files/piecechain.zip">piecechain.zip</a>      
    
  </div>

    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox">
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Neatpad</span>
        

        
        <ul>
          
            
            

            
            

            <li><a href="" class=""></a></li>
          
            
            

            
            

            <li><a href="index.html" class="">Neatpad Overview</a></li>
          
            
            

            
            

            <li><a href="loading-text-file.html" class="">Loading a text file</a></li>
          
            
            

            
            

            <li><a href="scrollbars-scrolling.html" class="">Scrollbars &amp; Scrolling</a></li>
          
            
            

            
            

            <li><a href="enhanced-drawing-painting.html" class="">Enhanced Drawing &amp; Painting</a></li>
          
            
            

            
            

            <li><a href="mouse-selection-highlighting.html" class="">Mouse Selection &amp; Highlighting</a></li>
          
            
            

            
            

            <li><a href="scrolling-mouse.html" class="">Scrolling with the Mouse</a></li>
          
            
            

            
            

            <li><a href="margins-and-long-lines.html" class="">Margins and Long Lines</a></li>
          
            
            

            
            

            <li><a href="introduction-unicode.html" class="">Introduction to Unicode</a></li>
          
            
            

            
            

            <li><a href="unicode-text-processing.html" class="">Unicode Text Processing</a></li>
          
            
            

            
            

            <li><a href="transparent-text.html" class="">Transparent Text</a></li>
          
            
            

            
            

            <li><a href="introduction-uniscribe.html" class="">Introduction to Uniscribe</a></li>
          
            
            

            
            

            <li><a href="uniscribe-mysteries.html" class="">Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="more-uniscribe-mysteries.html" class="">More Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="drawing-styled-text-uniscribe.html" class="">Drawing styled text with Uniscribe</a></li>
          
            
            

            
            

            <li><a href="integrating-usplib.html" class="">Integrating UspLib</a></li>
          
            
            

            
            

            <li><a href="keyboard-navigation.html" class="">Keyboard Navigation</a></li>
          
            
            

            
            

            <li><a href="piece-chains.html" class="active">Piece Chains</a></li>
          
            
            

            
            

            <li><a href="unicode-text-editing.html" class="">Unicode Text Editing</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>
    

  
  </div>


  <article class="page" itemscope="" itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Piece Chains">
    <meta itemprop="description" content="OK so I lied about getting the syntax-highlighting implemented this time around. I got bogged down in “regular expression hell” and needed something else to concentrate on. So during the summer period I’ve instead been slowly implementing Neatpad’s text-editing capability. As I hinted at in the very first installment of this tutorial series, I have decided to follow the “Piece Table” design. The aim of this tutorial will be to discuss the rationale behind this decision and also highlight some (but not all) of the implementation details. Note that I will not be discussing issues related to the editing of Unicode text (this will come in the next tutorial). Instead we will look at the design of the piece-table from a low-level perspective, independent of any Unicode concerns.">
    <meta itemprop="datePublished" content="September 12, 2006">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Piece Chains
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <!--h1>Piece Chains</h1-->
<!--h3>Editing text with Piece Chains</h3-->

<p>さて、今回はシンタックスハイライトを実装したのは嘘です。正規表現地獄」にはまってしまい、何か他に集中できるものが必要だったのです。そこで、夏の間、代わりにNeatpadのテキスト編集機能を少しずつ実装してきました。このチュートリアルシリーズの最初の回でほのめかしたように、私は「ピーステーブル」のデザインを採用することにしました。このチュートリアルの目的は、この決定の理由を説明し、実装の詳細を紹介することにあります。なお、Unicodeテキストの編集に関する問題については触れません（これについては次のチュートリアルで説明します）。その代わりに、ユニコードの問題とは無関係に、低レベルの観点からピーステーブルの設計を見ていきます。

</p>

<p>私がHexEditを書き始めた数年前には、エディタのデザインに関する情報はほとんどありませんでした。当時はまだGoogleは存在せず、AltaVistaが検索エンジンでした。私は33kのダイアルアップモデムを使っていましたが、当時偶然見つけた唯一の情報源は、Charles Crowleyという大学教授が書いた論文でした。彼の論文「Data Structures for Text Sequences」と彼が説明した「Piece Table」アプローチは、HexEditの設計に大きな影響を与え、最も洗練されたhex-editorsの1つとなりました。後に私は、HexEditのピーステーブル設計（当時はスパンテーブルと呼んでいた）を「Memory Management for Large File Editors」という記事で紹介しました。今日では、ピーステーブルに関する情報が少しずつ増えてきており、このデザインを自分のプロジェクトで使用している人の証拠も増えてきているようです。
</p>

<ul>
  <li>AbiWordは、非常に優れたクロスプラットフォームのオープンソースのワープロパッケージです。著者の中には、ブログでAbiWordのデザインについて議論している人もいます。特に注目すべきは、AbiWordのピーステーブルのデザインに関する議論で、著者はピーステーブルの「赤黒」の二分木表現への移行について詳しく説明しています。
</li>
  <li>WinAsm Studioは、アセンブリ言語によるプログラミングのためのIDEです。Antonis Kyprianou(著者)は、このIDEに組み込むための「ピーステーブル」ベースのエディタも書いています。
</li>
  <li>Tweakは、ターミナルベースのUnixの16進法エディタです。ウェブサイトの説明によると、tweakはファイルへの編集を表現するためにバイナリツリーのデータ構造を使用しています。この記事は一読の価値があり、非常に興味深い情報が掲載されています。
</li>
  <li>C++ Ropeクラスはとても面白そうですね。私は、そのページに書かれていること以外、ほとんど何も知りません。説明によると、ロープクラスはピーステーブル実装を使用しているようですが、私はこれを確信していません。
</li>
</ul>

<p>ピーステーブルは決して新しいものではなく、数年前から何らかの形で存在していました。

</p>

<ul>
  <li>Xerox PARC（Palo Alto Research Center）は、1970年代にテキストエディター「Bravo」を開発しました。BravoはCharles Simonyi氏とButler Lampson氏の作品で、編集機能を実装するために「Piece Chain」を使用していました。残念ながら、Bravoが動作していたAltoプラットフォームは非常に古くなってしまったため、Bravoエディタに関する情報はもう手に入らないようです。もしかしたら、Altogetherプロジェクト（Altoのエミュレータ）が軌道に乗り、これらの古いコンピュータシステムを再発見できるかもしれません。
</li>
  <li>
    <p>Project Oberonは、オペレーティングシステム、コンパイラ、プログラミング言語です。コンピュータ科学の古典である『Project Oberon』は、こちらからPDF形式で入手でき、Oberonプラットフォームの設計について詳しく書かれています。この本には、テキスト管理に関する非常に興味深い章があり、その中でピースチェイン技術が詳細に説明されています。

</p>
  </li>
  <li>Mutable Textは、テキストストリームを編集するためのModula-3インターフェースです。MTextは、効率化のためにバランスドバイナリーツリーを使ったピーステーブルデザインを実装しています。MTextインターフェイスに関する情報は、Compaqの古い研究用ウェブサイトからしか得られませんでした。Compaqはもう存在しない（HPが買収した）ので、この情報を見つけるにはGoogle-Cacheを使わなければなりませんでした。
</li>
</ul>

<p>ピースチェーンの技術は、30年以上前から存在しており、最初に注目されたのはBravoエディターでした。驚くべきことに、この手法は現在でも非常に珍しいものなのです。

</p>

<h2 id="the-perfect-text-editor">The Perfect Text Editor</h2>

<p>もちろん、完璧なテキストエディタというものは存在しません。そうでなければ、皆が同じツールを使っているはずですし、私が完璧なエディタのビジョンを作ろうとして、この記事シリーズを書くこともないでしょう。

</p>

<p>エディタのユーザーインターフェイスのデザインの圧倒的な違いを無視しても、エディタの実装には大きな多様性があります。つまり、すべてのテキストエディタが採用している単一の「真の」デザインは存在しないということです。例えば、バッファギャップ方式、行間リンク方式、ピースチェーン方式などがあります。

</p>

<p>ピースチェーン方式があまり一般的でない理由の一つは、テキストエディタでの実装が複雑なことです。難しいのは実際のピース管理ではなく、エディタのラインバッファの管理が面倒なのです。このような理由から、多くのエディタはピースチェーンを実装しないことにしており、ViやEmacsのような成熟したエディタは、このようなデザインでなくても非常に成功していると言えます。

</p>

<p>このような手法が存在するということは、テキストエディタに圧倒的な「ベスト」デザインが存在しないことを示しています。Neatpadにピーステーブルを導入することが正しい判断なのかどうかは、今のところわかりません。しかし、私はこのプロジェクトを完成させたいと思っています。少なくとも、ピーステーブルのデザインがプレーンテキストエディタに適しているかどうかは、何らかの方法で知ることができるでしょう。

</p>

<h2 id="piece-chains-with-linked-lists">Piece Chains with Linked Lists</h2>

<p>Neatpadは、HexEditのオリジナルデザインを忠実に再現した二重リンクリストを使って、ピースチェーンデータ構造を実装しています。これは、HexEditのオリジナルデザインを忠実に再現しています。バイナリツリーなどの他の構造を使用することもできますが、単純さの点でリンクリストが好まれます。HexEditのオリジナルデザインでは、ピースチェーンの始点と終点を表すHeadとTailのポインターが用意されています。ほとんどの人はこの概念を知っていると思いますが、知らない人は先に進む前にこのテーマについて読んでみることをお勧めします。いずれにせよ、HexEditで使用した古典的な2重リンクリストを以下に示します。

</p>

<p><img src="assets/img/editor1712.gif" alt="" class="align-center"></p>

<p>以下のスニペットは、このようなリンクリストの初期化方法を示しています。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sequence constructor
</span><span class="n">sequence</span><span class="o">::</span><span class="n">sequence</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>このデザインのちょっとした問題点は、ヘッドポインタとテールポインタの管理方法です。ノードがリストの前後に挿入されるたびに、このような「特別な場合」の条件を処理するために特定のコードが必要になります。なぜなら、ヘッドまたはテールのポインタが新しいノードを指すように更新される必要があるからです。リンク管理は煩雑で、シーケンス操作を非常に複雑にしています。

</p>

<p>もう一つのデザインは、「センチネル」と呼ばれるノードを維持することです。このモデルでは、リストの最初と最後に2つのダミーノードが導入されます。その内容は定義されませんが（長さは0になります）、その存在自体が、リストのすべてのノードが有効な隣人を持つことを保証することになります。言い換えれば、センチネル自体を除けば、すべてのノードの次のリンクと前のリンクは常に有効なノードを指しています。これにより、リストの最初と最後の挿入や削除を処理するための「特殊なケース」のコードは基本的に削除されます。

</p>

<p><img src="assets/img/editor1713.gif" alt="Linked-list with sentinel nodes" class="align-center">
<em class="align-center">Linked-list with sentinel nodes.</em></p>

<p>さらに説明すると、空のリストには2つのノード、つまりヘッドセンティネルとテールセンティネルが含まれており、これらは単にお互いを指しているだけです。

</p>

<p><img src="assets/img/editor1714.gif" alt="Empty List" class="align-center">
<em class="align-center">Empty list.</em></p>

<p>このリンクリストのデザインをサポートするのはとても簡単です。ヘッドポインタとテールポインタをNULLに初期化する代わりに、2つの「空」のノードを作成し、お互いにリンクします。その後に追加されたノードは、センティネルの間に挿入されます。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sequence</span><span class="o">::</span><span class="n">sequence</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>この単純なアイデアで、どれだけの作業を省けるかは驚くべきことです。もちろん、この方法は私の手柄ではありません。何年も前にMichael Abrash氏のアセンブリ最適化の本の中でこのトリックを読んだことがあります。

</p>

<h2 id="spans-and-pieces">Spans and Pieces</h2>

<p>ピースチェーンという用語は、データ構造の中でテキストの断片が連鎖していく様子をすぐに想像できるので、簡潔で良いと思います。しかし、Neatpadでは、チェーン内の各テキストピースを表すのにspanという用語を使っていますが、これは純粋にHexEditでのやり方がそうだったからです。ピースとスパンの間には、名前以外の違いはなく、どちらも同じ目的を持っています。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// span - private to the sequence
</span><span class="k">struct</span> <span class="n">span</span>
<span class="p">{</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">prev</span><span class="p">;</span>

    <span class="n">size_w</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">size_w</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>ピーステーブルは、spanオブジェクトをnextとprevのリンクで連結することで形成されます。リンクリストは、データ構造全体を単一のオブジェクトにカプセル化したシーケンスC++クラスによって維持されます。編集用のインターフェイスとして、挿入、置換、消去の各関数が用意されています。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// define the type of strings the sequence will hold
</span><span class="k">typedef</span> <span class="kt">wchar_t</span> <span class="n">seqchar</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">sequence</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">insert</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">seqchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">replace</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">seqchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">erase</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">undo</span> <span class="p">();</span>
    <span class="kt">bool</span> <span class="n">redo</span> <span class="p">();</span>

    <span class="c1">// other members snipped
</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">head</span><span class="p">;</span> <span class="c1">// pointers to list sentinels
</span>    <span class="n">span</span> <span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>スパンの基本的な考え方は、基礎となるファイルコンテンツへのインダイレクトのレベルを提供することです。個々のノードは、いかなるテキストも格納しません。オリジナルファイルに格納されたテキストの範囲、またはテキストの挿入によって追加されたmodify-buffer内のテキストの範囲を参照するだけです。上記の定義から、スパンにはテキストを格納する手段がないことがわかります。代わりに、オフセット、長さ、バッファの各フィールドが、オリジナルファイルのテキストの範囲（または部分）を特定します。

</p>

<p>下の図は、典型的なピースチェーンの構成を示しています。original file」バッファは、「The brown fox jumped over the lazy dog」というテキストで初期化されています。このテキストは、modify バッファに追加されていますが、「ing」という単一の単語がシーケンスに挿入されています。ピースチェーンのスパンは、シーケンス「The jumping dog」を形成しています。

</p>

<p><img src="assets/img/editor1716.gif" alt="<>" class="align-center"></p>

<p>ここで重要なことは、スパンはシーケンス内の論理的な位置を知らないということです。スパンが知っているのは、参照しているデータの物理的な位置だけです。このため、新しいスパンをピースチェーンに挿入または削除しても、リスト内の他のスパンには影響を与えないという利点があります。ピーステーブルの挿入と削除が非常に高速なのはこのためです（挿入する場所がわかっている場合）。

</p>

<p>ピーステーブルの柔軟性は、同時に最大の欠点でもあります。スパンは自分の論理的な位置を知らないので、ドキュメント内の特定のテキストオフセットに直接アクセスする方法がありません。すべてのアクセスは、リストの先頭から始めてリンクされたリストを経由しなければなりません。特定の文字のオフセットを見つけたいときは、各スパンを順に繰り返し、現在の論理的位置を追跡するために、その長さを合計しなければなりません。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">span</span> <span class="o">*</span> <span class="n">sequence</span><span class="o">::</span><span class="n">spanfromindex</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">size_w</span> <span class="o">*</span><span class="n">spanindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">span</span> <span class="o">*</span><span class="n">sptr</span><span class="p">;</span>
    <span class="n">size_w</span> <span class="n">curidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// scan the list looking for the span which holds the specified index
</span>    <span class="k">for</span><span class="p">(</span><span class="n">sptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">sptr</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">curidx</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">curidx</span> <span class="o">+</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">spanindex</span><span class="p">)</span> 
                <span class="o">*</span><span class="n">spanindex</span> <span class="o">=</span> <span class="n">spanidx</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">sptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">spanidx</span> <span class="o">+=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// insert at tail?
</span>    <span class="k">if</span><span class="p">(</span><span class="n">sptr</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="n">curidx</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">spanindex</span> <span class="o">=</span> <span class="n">curidx</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">sptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上記の spanfromindex 関数は、スパンの位置を特定するためにピースチェーンを最初から走査する方法を示しています。各スパンの長さは、正しいノードが見つかるまで合計されます。リンクリストの設計が単純であることは、最大の欠点でもあります。リンクリストへのランダムアクセスは遅いのです。

</p>

<h2 id="unlimited-undo--redo">Unlimited Undo &amp; Redo</h2>

<p>理論的には、ピーステーブルを使えば、無制限のundo+redoは信じられないほど簡単です。実際、ほとんど「無料」です。これが、この技術が魅力的である理由のひとつです。私にとっての大きなセールスポイントは、ピースチェーンが（コンピュータ科学の用語でいうところの）永続的データ構造であることです。つまり、ピースチェーンは、変更されても古いバージョンの自分自身を保存することができるのです。最も重要なのは、これらの古いバージョンが、データ構造の完全性を維持したまま、簡単に復元できることです。

</p>

<p>編集中のファイルの基本的なデータは変更されないことを覚えておくことが重要です。ファイルの変更を表現するために変更されるのはリンクリストのノード（スパン）だけです。そのため、変更されたドキュメントの内容を含む別のデータバッファを維持する必要はありません。ピースチェーンがもたらすメモリの節約は、この方法で追加される複雑さを正当化するのに十分なほど重要です。

</p>

<p>Neatpadのアンドゥ/リドゥの実装の鍵は、スパンレンジの使用にあります。簡単に言うと、スパンレンジとは、シーケンス内のスパンの連続した範囲を表すオブジェクトです。ピースチェーンが操作されるたびに、スパンレンジオブジェクトがアンドゥスタックにプッシュされ、編集の影響を受けるスパンの範囲を表します。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">span_range</span>
<span class="p">{</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">last</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">boundary</span><span class="p">;</span>
    <span class="n">size_w</span> <span class="n">sequence_length</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>したがって、各スパンレンジは、シーケンスに対する1つの修正を表すために使用されます。最初と最後のフィールドは、特定の編集操作を包含するスパンの範囲を示します。範囲内のすべてのスパンは、通常のnextとprevのポインタを使用して内部的にリンクされています。span-rangeは、概念的には複数のスパンを連結して保持することができますが、firstとlastの両方を同じスパンに向けることで、単一のスパンを参照することもできます。

</p>

<p>各スパンレンジ内にシーケンスレングスが格納されていることに注目してください。これは、操作を取り消したりやり直したりするたびに、シーケンス長を再計算したくないからです（大きなピースチェーンでは、再計算すると非常に時間がかかります）。シーケンスを編集する前にシーケンスレングスを保存しておけば、アンドゥの際にこの値を簡単に復元できます。

</p>

<p>スパン境界は、スパン範囲の特殊な形態です。スパン境界は、隣接する2つのスパンの間のギャップと考えてください。スパン範囲は、このような形の「空」の範囲を表すためにも使用され、その境界フィールドは、どのような種類の範囲であるかを示すために「true」に設定されます。

</p>

<p><img src="assets/img/editor1715.gif" alt="" class="align-center"></p>

<p>上の画像は、両方の種類のスパンレンジを示しています。左側の範囲は「通常の」範囲で、boundary は false に設定されています。右側の範囲は「空」の範囲で、span-rangeオブジェクトのboundaryフィールドがtrueに設定されています。

</p>

<p>実際には、スパン・レンジは履歴を保持するだけではなく、挿入や消去の際にスパンを操作する際の補助的なヘルパー・オブジェクトとしても使用されます。スパンレンジは、ピースチェーンのセクションをシーケンスに出し入れする際に保存する便利な方法です。

</p>

<h2 id="inserting-data">Inserting Data</h2>

<p>データの挿入は、圧倒的に簡単に実装できます。考慮すべき基本的なシナリオは、スパンの中央に挿入する場合と、スパンの境界に挿入する場合の2つです。これらの操作を詳しく見ていくと、テキストシーケンスの編集は、リストのスパンの変更に過ぎないことを覚えておいてください。なお、これらの例では、テキストは各スパンの中に含まれていることが示されています。実際には、スパンにはテキストは含まれておらず、元のバッファや修正バッファのテキストの範囲を参照していることがわかっているからです。さらに、ヘッドとテールのセンチネル・ノードも、リストの両端にあるグレーのブロックとして表示されています。

</p>

<p>スパンの途中で挿入するというのが、最初のシナリオです。まず、ピースチェーンを次のような状態にします。

</p>

<p><img src="assets/img/editor1706.gif" alt="" class="align-center"></p>

<p>シーケンスにはテキスト "TheQuickBrown "が格納され、リンクリストには何らかの理由で3つのスパンが格納されています。最初の例では、インデックス "6 "に文字列 "xxxx "を挿入します。シーケンス内のこの位置は、たまたま2つ目のスパンの中央に位置しています。

</p>

<p><img src="assets/img/editor1707.gif" alt="" class="align-center"></p>

<p>スパンの途中で挿入するには、スパンを2つに分割する必要があります（挿入ポイントの前後のデータを表す）。この2つの新しい部分の間に、実際に挿入されるデータを表す3つ目の部分がリンクされます。予想通り、挿入されたデータは「修正バッファ」に追加され、元のファイルバッファはそのまま残されます。

</p>

<p><img src="assets/img/editor1704.gif" alt="" class="align-center"></p>

<p>概念的には、「挿入」を表現するためにスパンを半分に分割しましたが、実際にはこのようなことはしません。ピースチェーンを見ると、「Quick」という単語を表すスパンがシーケンスから削除され、3つの新しいスパンで置き換えられているのがわかります。しかし、このスパンを削除するのではなく、span-rangeオブジェクトの中に保持することで保存しています。このスパンレンジは、挿入によって変更されたスパンの範囲を表すために、「元に戻すスタック」に押し込まれます。

</p>

<p>このスパン保存の戦略は、今回の永続的データ構造の実装において重要です。挿入が行われた後、ピースチェーン内のどのスパンも「Quick」スパンを参照しなくなっていることに注目してください。しかし、「Quick」は、メインリストに戻る独自のリンクを維持しています。これは非常に重要な点で、順序を元に戻す（この最後のアクションを元に戻す）際に、undo-stack上のスパンがリストのどの位置に再挿入されるべきかを知る必要があるからです。

</p>

<p>今回のシナリオでは、sequence::insert関数を用いて、データの挿入方法の基本的な概要を示しています。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// initialize a new 'undo'. It will be pushed onto the undo-stack.
</span><span class="n">span_range</span> <span class="o">*</span><span class="n">oldspans</span> <span class="o">=</span> <span class="n">init_undo</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">action_insert</span><span class="p">);</span>
<span class="n">span_range</span> <span class="n">newspans</span><span class="p">;</span>

<span class="c1">// preserve the span that we are inserting into
</span><span class="n">oldspans</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">sptr</span><span class="p">);</span>

<span class="c1">// new spans for before and after the insertion point
</span><span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">insoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
<span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">modbuf_offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">modifybuffer_id</span><span class="p">));</span>
<span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">+</span><span class="n">insoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="n">insoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>

<span class="c1">// insert the new pieces into the sequence!!
</span><span class="n">swap_spanrange</span><span class="p">(</span><span class="n">oldspans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newspans</span><span class="p">);</span>
<span class="n">sequence_length</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
</code></pre></div></div>

<p>Neatpadの配列変更は、すべて同じ基本パターンに従います。

</p>

<ol>
  <li>シーケンスから削除されるスパンは、"oldspans "というスパンレンジ内に格納されます。

</li>
  <li>シーケンスに導入されるスパンは、"newspans "というスパンレンジの中に格納されます。

</li>
  <li>oldspans」はundo-stackに押し込まれます。

</li>
  <li>そして、2つのスパン・レンジを入れ替えます。

</li>
</ol>

<p>次に、スパンの境界に挿入する場合を考えてみましょう。この例では、2文字の文字列 "yy "が再びシーケンスポジション "6 "に挿入され、"Qui "と前回挿入した "xxxx "の間に入ります。

</p>

<p><img src="assets/img/editor1708.gif" alt="" class="align-center"></p>

<p>今回は、"Qui "ノードと "xxxx "ノードの間に、1つのスパンがリストに挿入される。この動作を表すundo-eventは、insertion-boundaryの両側のスパンを保持するspan-rangeである。この「スパン境界」は「*」記号で区別される。これらのスパンが再びリンクリストへのリンクを維持していることに注目してください。

</p>

<p><img src="assets/img/editor1705.gif" alt="" class="align-center"></p>

<p>もうひとつの重要な点は、新しいスパンレンジが追加されたことで、アンドゥスタックが大きくなっていることです。マルチレベルのアンドゥがどのように実装されているかお分かりいただけたでしょうか。シーケンスを編集するたびに、undo-stackに別のスパンレンジが押し込まれます。このスタックの各エントリは、その特定の編集操作によって影響を受けたスパンの範囲を表しています。undo」を実行するたびに、スパンレンジはundo-stackから「popped」され、メインのリンクリストに再び挿入される。置き換えられたスパンは削除されますが、リストに戻るための独自のリンクは維持されます。undo中に削除された各span-rangeは、redoスタックに押し込まれます。

</p>

<p>今回は1つのスパンしか挿入されないので、スパン境界挿入のコードはよりシンプルになっています。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// initialize a new 'undo' 
</span><span class="n">span_range</span> <span class="o">*</span><span class="n">oldspans</span> <span class="o">=</span> <span class="n">init_undo</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">action_insert</span><span class="p">);</span>
<span class="n">span_range</span> <span class="n">newspans</span><span class="p">;</span>

<span class="c1">// this is a 'boundary insertion' 
</span><span class="n">oldspans</span><span class="o">-&gt;</span><span class="n">spanboundary</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">sptr</span><span class="p">);</span>

<span class="c1">// single span for the inserted data
</span><span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">modbuf_offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">modifybuffer_id</span><span class="p">));</span>

<span class="c1">// insert the new span into the sequence in place of the old ones
</span><span class="n">swap_spanrange</span><span class="p">(</span><span class="n">oldspans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newspans</span><span class="p">);</span>
<span class="n">sequence_length</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
</code></pre></div></div>

<p>コードは以前と同じパターンで、「oldspans」を定義し、「newspans」を集めて、それらを入れ替えます。今回の唯一の違いは、「oldspans」の定義方法です。境界挿入のケースではスパンは変更されていないので、span-rangeは、挿入した境界の両側のスパンを指すことで、スパン境界を表している。

</p>

<h2 id="erasing-data">Erasing Data</h2>

<p>シーケンスからデータを消去するのは、もっと複雑です。実際には、もっともっと複雑です。問題は、削除が複数のスパンにまたがる可能性があり、スパンの途中で開始したり停止したりすることです。ここでは、そのようなシナリオを想定しています。

</p>

<ul>
  <li>消去は、スパンの境界から開始します。

</li>
  <li>消去はスパンの途中から始まります（その場合はスパンを分割する必要があります）。

</li>
  <li>消去は、スパンとノードの境界で停止します。

</li>
  <li>スパンの途中で停止した箇所を消去する（この場合もスパンは分割されているはず）。

</li>
</ul>

<p>また、1つの削除が複数のスパンにまたがる場合も考慮しなければなりません。この場合、上記の4つのシナリオすべてを考慮しなければなりません。また、削除箇所が1つのスパンに完全に含まれる場合もあります。この場合も、境界条件やスパン中間部の条件を考慮する必要があります。

</p>

<p>HexEditのピースチェーン実装で私が犯した過ちは、これらのケースをすべて別々に処理したことで、結果的に非常に複雑なコードになってしまいました。私がすべきだったこと、そして今回私がしたことは、すべてのシナリオを処理する1つの「一般的なケース」を用意することでした。

</p>

<p><img src="assets/img/editor1710.gif" alt="" class="align-center"></p>

<p>上の例では、複数のスパンにまたがる削除を行っており、スパンの途中で開始したり停止したりしています。

</p>

<p><img src="assets/img/editor1711.gif" alt="" class="align-center"></p>

<p>削除はリストのすべてのスパンに影響を与えたため、リンクリスト全体がスパンレンジの形で undo-stack に押し込まれ、削除されたレンジの前後のデータを表す 2 つの新しいスパンに置き換えられます。

</p>

<p>コードはまず、削除がスパンの途中から始まっているかどうかをチェックします。削除された場合、そのスパンは oldspans の範囲に追加され、削除インデックスの直前のスパンのデータを表す代替スパンが作成されます。この「分割」されたスパンはnewspansの範囲に追加されます。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// does the deletion *start* mid-way through a span?
</span><span class="k">if</span><span class="p">(</span><span class="n">remoffset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// split the span - keep the first "half"
</span>    <span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">remoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>

    <span class="c1">// have we split a single span into two?
</span>    <span class="c1">// i.e. the deletion is completely within a single span
</span>    <span class="k">if</span><span class="p">(</span><span class="n">remoffset</span> <span class="o">+</span> <span class="n">removelen</span> <span class="o">&lt;</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// make a second span for the second half of the split
</span>        <span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span>
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">remoffset</span> <span class="o">+</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">remoffset</span> <span class="o">-</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
            <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">removelen</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">removelen</span><span class="p">,</span> <span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">remoffset</span><span class="p">));</span>

    <span class="c1">// archive the span we are going to delete
</span>    <span class="n">oldspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sptr</span><span class="p">);</span>
    <span class="n">sptr</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>この最初のシナリオが処理されると、削除範囲の最後に到達するまで、ループを使用してさらにすべてのスパンを処理します。削除範囲」に該当するすべてのノードは、oldspansコンテナ・オブジェクトに追加されます。削除がスパンの途中で停止した場合のシナリオを処理するために、特殊なケースが使用されます。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// we are now on a proper span boundary, so remove
// any further spans that the erase-range encompasses
</span><span class="k">while</span><span class="p">(</span><span class="n">removelen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sptr</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// will the entire span be removed?
</span>    <span class="k">if</span><span class="p">(</span><span class="n">removelen</span> <span class="o">&lt;</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// split the span, keeping the last "half"
</span>        <span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span>
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
            <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">removelen</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">removelen</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

    <span class="c1">// archive the span we are replacing
</span>    <span class="n">oldspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sptr</span><span class="p">);</span>
    <span class="n">sptr</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最後にすることは、「oldspans」と「newspans」を入れ替えて、配列長を更新することです。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">swap_spanrange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldspans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newspans</span><span class="p">);</span>
 <span class="n">sequence_length</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
</code></pre></div></div>

<p>これらのコードはすべて sequence::erase メンバ関数に含まれていますが、ここで紹介したものよりもはるかに複雑です。特に、「最適化」された削除のための特殊なケースがあり、必要なコードの量はほぼ2倍になります。このプロセスをこれ以上詳しく説明するつもりはありません。興味のある方はダウンロードしたソースコードをご覧ください。

</p>

<h2 id="replacing-data-overwriting">Replacing Data (overwriting)</h2>

<p>データの置き換えは、実装が最も複雑な操作であり、消去と挿入を組み合わせて1つの機能にしたものと考えるべきです。sequence::replaceを実装する際には、これらの最初の2つの操作の複雑さをすべて考慮する必要があります。さらに，「最適化された置換」シナリオ（複数の連続した置換を1つの操作にまとめる）は，replaceを非常に複雑にします．ここでは詳細を説明しませんが，ダウンロードしたソースコードには必要な情報がすべて含まれていますので，ご安心ください．

</p>

<p>HexEditのシーケンスクラスを最初に書いたとき、シーケンス内のデータを置き換えるためのルーチンを別個に書いてしまったのがもう一つの失敗でした。すでに複雑になっていた「消去」関数のコードを複製して、新たに「置換」関数を作りました。さらに、データを挿入するコードを追加したため、さらに複雑になってしまいました。重複したコードのために、コードの管理が非常に難しくなってしまいました。

</p>

<p>2回目は同じ間違いをしませんでした。Neatpadのsequence::replace関数は、sequence::eraseとsequence::insertのラッパーに過ぎません。まず最初にeraseが呼ばれ、置き換えられるデータの範囲を削除します。これにより、一時的にシーケンスが短縮されます。次にinsertが呼ばれ、「replace」データが削除された場所に挿入され、シーケンスが元の長さに戻ります。重要なのは、これらの2つのアクションがグループ化されており、1つの元に戻すことができないアクションとして表示されることです。

</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">sequence</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">seqchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">group</span><span class="p">();</span>
    <span class="n">erase</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">ungroup</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>sequence::replaceをこのように記述することで、シーケンスの実装が大幅に簡素化されました。最適化された置き換え」の問題があるため、私が考えているほど簡単ではありませんでした。シーケンス::消去関数は、「通常の消去」と「置き換えによる消去」に対応するために、わずかなロジックを持たなければなりません。しかし、一般的には、この「ショートカット」は、以前に行っていた方法よりもはるかに好ましいと感じました。重要なのは、消去や挿入の関数を変更しなければならないとき（例えば、バグのため）、並行してreplace関数を変更する必要がないということです。

</p>

<h2 id="piece-chain-demo-application">Piece-chain demo application</h2>

<p>ピースチェーンの実装をテストするのは、微妙なシナリオが発生する可能性があるため、かなり困難です。私はまず、単純なコンソールアプリケーションで「インデックステキストを挿入」や「インデックス長を消去」と入力することから始めました。これはかなり面倒だったので、以前のチュートリアルで書いたUspLib Demoアプリケーションを利用して、「Piece Chain Demo」を作ってみました。

</p>

<p><img src="assets/img/editor1717.gif" alt="" class="align-center"></p>

<p>この形式のテストハーネスは、各操作後のピースチェーンの状態を即座にフィードバックしてくれるので、非常に便利です。また、Original File、Modify-Buffer、Undo stackの内容も表示されます。ピースチェーンをNeatpadに統合してしまった今となっては、それほど便利ではありませんが、少なくともピースチェーンについて学ぼうとしている人には面白いかもしれません。ぜひ試してみてください。

</p>

<h2 id="linked-lists-vs-binary-trees">Linked Lists vs Binary Trees</h2>

<p>ピーステーブルをどのように表現するかについては、いくつかの議論があります。2つの主な選択肢は、リンクリストか、ある種のバイナリツリーです。今のところ、Neatpadでは、ピーステーブルの管理に二重リンクリストを使用しています。この方法は、私のHexEditアプリケーションで効果的であることが証明されていますが、リンクリストがテキストエディタに適しているかどうかは、まだわかりません。

</p>

<p>リンクされたリストは、操作やトラバースが非常に簡単です。しかし、リストに多数のノードがある場合、特定の文字位置を探すのに非常に時間がかかる可能性があります。なぜなら、特定のノードが必要になるたびに、リストを最初から走査しなければならないからです。キャッシングは、リンクリストの速度問題のほとんどを解決することができます。なぜなら、シーケンスに対する操作の大部分は非常に局所的なものだからです（一度に入力できるのは、ドキュメントの固定されたビューポート内だけです）。最後にアクセスされたスパンをキャッシュすることで、ここでも大きな改善が得られます。

</p>

<p>一方、二分木はその正反対の性質を持っています。バランス型二分木は、検索には向いていますが、挿入や修正には向いていません。検索は常にO(log N)なので、何千ものノードを持つシーケンスであっても、特定の文字位置の検索は常にかなり高速です。しかし、バイナリツリーの操作はリンクリストに比べて常にかなり高価です。ノードがバイナリツリーに挿入されるたびに、ツリーはリバランスされ、そのノードのすべての子は変更を反映して更新されなければなりません。

</p>

<p>いずれの場合も、選択したデータ構造の複雑さ（含まれるスパンの数）は、ファイルの編集回数の関数であり、ファイルのサイズや含まれる行数とはまったく関係ありません。このため、ピースチェーンは、非常に大きなファイルであっても拡張性が高く、優れたデータ構造となっています。これは、大規模なファイルには対応できない「行のリンクリスト」モデルよりもはるかに優れています。私の意見では、ピーステーブルは間違いなく最適なデータ構造です。

</p>

<p>純粋にpiece-tableの編集だけを考えた場合、リンクリストの方が優れていると思います。もし、データ構造を他の種類の検索（行番号の検索や行番号と文字オフセットのマッピングなど）に使用する必要がある場合は、バイナリツリーの実装に移行する必要があるかもしれません。

</p>

<h2 id="c-templates-and-vs2005">C++ templates and VS2005</h2>

<p>今のところ、C++のテンプレートを使ってシーケンスクラスを実装したいという誘惑には勝てませんでした。これは、VC6.0のテンプレートサポートが貧弱であることが主な理由ですが、初期バージョンでは、C++プログラマーでなくても理解できるように「クリーン」にしたかったのです。現在、シーケンスクラスは、テキストの基本単位として、ハードコードされた'seqchar'データタイプを使用しており、これは現在16ビットのWCHARタイプです。sequence.hの先頭にあるtypedef文を変更するだけで、シーケンスを他の文字型に対応させることができるので、当面の間、テンプレートは必要というよりは贅沢なものとなるでしょう。

</p>

<p>しかし、私は最近VS2005を使い始め、より優れたC++コンパイラを利用する機会を得ました。もし、VS2005に移行すると、プロジェクトに互換性がないため、VC6.0でNeatpadをコンパイルすることが難しくなります。また，シーケンスクラスをテンプレート実装に変更すると，VC6.0ではNeatpadをまったくコンパイルできなくなります。この提案について、みんなはどう思う？もしコメントがなければ、私はVS2005への移行を進めますが...。

</p>

<h2 id="conclusion">Conclusion</h2>

<p>私は、ピースチェーンの実装をできる限りシンプルにすることを意図しています。現段階では、ピースチェーンの実装をバイナリツリーに移行する必要はないと考えていますが、パフォーマンスが問題になるようであれば、今後のチュートリアルでこの問題に取り組む必要があるかもしれません。重要なのは、リストを使おうがツリーを使おうが、実際には問題ではないということです。すべてはシーケンスC++クラスの中にカプセル化されているので、バイナリツリーに変更しても他の設計には実質的な影響はありません。

</p>

<p>ピーステーブルは実際には非常にシンプルな概念であり、この記事から想像されるほど複雑ではありません。複雑なのは、編集が発生するたびにピースチェインが最適化される方法から生じます。連続した挿入、消去、置換は、リスト内のスパン数が常に最小になるようにまとめられます。このため、編集が発生するたびにテーブルに新しいスパンを導入するのではなく、個々のスパンを「その場で」調整する必要があります。これは、undo/redoのサポートも複雑にします。このように最適化されていないピースチェーンは非常にシンプルですが、残念ながら「現実世界」のピースチェーンが成功するためには、これらの機能を備えていなければなりません。

</p>

<p>次のチュートリアルでは、ピースチェーンのデザインをどのようにNeatpadに統合したかを中心に説明します。Unicodeテキストの編集には微妙な問題があるため、議論すべきことがたくさんあります。また、適切な「メモリ管理」と大容量ファイルのサポートを実装する必要があります。これについても、後のチュートリアルで取り上げます。

</p>



  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="assets/files/piecechain.zip">piecechain.zip</a>      
    
  </div>

        
      </section>

      <footer class="page__meta">
        
        


        
          <p class="page__date"><strong><svg class="svg-inline--fa fa-calendar-alt fa-w-14 fa-fw" aria-hidden="true" data-prefix="fas" data-icon="calendar-alt" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M0 464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V192H0v272zm320-196c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM192 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM64 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM400 64h-48V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H160V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H48C21.5 64 0 85.5 0 112v48h448v-48c0-26.5-21.5-48-48-48z"></path></svg><!-- <i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> --> Updated:</strong> <time datetime="2006-09-12T00:00:00+00:00">September 12, 2006</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="../../tuts/win32/tips-and-tricks-part-2.html" class="pagination--pager" title="Win32 Tips &amp; Tricks - Part 2
">Previous</a>
    
    
      <a href="unicode-text-editing.html" class="pagination--pager" title="Unicode Text Editing
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div class="page__footer" style="">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="../../feed.xml"><svg class="svg-inline--fa fa-rss-square fa-w-14 fa-fw" aria-hidden="true" data-prefix="fas" data-icon="rss-square" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"></path></svg><!-- <i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> --> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">© 2019 Catch22. Powered by <a href="https://jekyllrb.com/index.html" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/index.html" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="assets/js/main.min.js"></script>
  <script defer="" src="https://use.fontawesome.com/releases/v5.6.0/js/all.js" integrity="sha384-z9ZOvGHHo21RqN5De4rfJMoAxYpaVoiYhuJXPyVmSs8yn20IE3PmBM534CffwSJI" crossorigin="anonymous"></script>








  

</body></html>