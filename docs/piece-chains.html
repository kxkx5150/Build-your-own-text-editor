<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.15.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<title>Piece Chains - Catch22</title>
<meta name="description" content="OK so I lied about getting the syntax-highlighting implemented this time around. I got bogged down in “regular expression hell” and needed something else to concentrate on. So during the summer period I’ve instead been slowly implementing Neatpad’s text-editing capability. As I hinted at in the very first installment of this tutorial series, I have decided to follow the “Piece Table” design. The aim of this tutorial will be to discuss the rationale behind this decision and also highlight some (but not all) of the implementation details. Note that I will not be discussing issues related to the editing of Unicode text (this will come in the next tutorial). Instead we will look at the design of the piece-table from a low-level perspective, independent of any Unicode concerns.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Catch22">
<meta property="og:title" content="Piece Chains">
<meta property="og:url" content="piece-chains">


  <meta property="og:description" content="OK so I lied about getting the syntax-highlighting implemented this time around. I got bogged down in “regular expression hell” and needed something else to concentrate on. So during the summer period I’ve instead been slowly implementing Neatpad’s text-editing capability. As I hinted at in the very first installment of this tutorial series, I have decided to follow the “Piece Table” design. The aim of this tutorial will be to discuss the rationale behind this decision and also highlight some (but not all) of the implementation details. Note that I will not be discussing issues related to the editing of Unicode text (this will come in the next tutorial). Instead we will look at the design of the piece-table from a low-level perspective, independent of any Unicode concerns.">







  <meta property="article:published_time" content="2006-09-12T00:00:00+00:00">






<link rel="canonical" href="piece-chains.html">













<!-- end _includes/seo.html -->


<link href="../../feed.xml" type="application/atom+xml" rel="alternate" title="Catch22 Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--tutorial wide">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="../../index.html">Catch22</a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="../../blog/index.html" >Blog</a>
            </li><li class="masthead__menu-item">
              <a href="../../software/index.html" >Software</a>
            </li><li class="masthead__menu-item">
              <a href="../../tuts/index.html" >Tutorials</a>
            </li><li class="masthead__menu-item">
              <a href="../../about/index.html" >About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="../../../schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="../../../schema.org/ListItem">
          <a href="../../index.html" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="../../../schema.org/ListItem">
          <a href="../../tuts.html" itemprop="item"><span itemprop="name">Tuts</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="../../../schema.org/ListItem">
          <a href="../../tuts/neatpad.html" itemprop="item"><span itemprop="name">Neatpad</span></a>
          <meta itemprop="position" content="3" />
        </li>
        <span class="sep">/</span>
                
      
    
      
      
        <li class="current">Piece Chains</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      
  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="assets/files/piecechain.zip">piecechain.zip</a>      
    
  </div>

    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Neatpad</span>
        

        
        <ul>
          
            
            

            
            

            <li><a href="" class=""></a></li>
          
            
            

            
            

            <li><a href="index.html" class="">Neatpad Overview</a></li>
          
            
            

            
            

            <li><a href="loading-text-file.html" class="">Loading a text file</a></li>
          
            
            

            
            

            <li><a href="scrollbars-scrolling.html" class="">Scrollbars & Scrolling</a></li>
          
            
            

            
            

            <li><a href="enhanced-drawing-painting.html" class="">Enhanced Drawing & Painting</a></li>
          
            
            

            
            

            <li><a href="mouse-selection-highlighting.html" class="">Mouse Selection & Highlighting</a></li>
          
            
            

            
            

            <li><a href="scrolling-mouse.html" class="">Scrolling with the Mouse</a></li>
          
            
            

            
            

            <li><a href="margins-and-long-lines.html" class="">Margins and Long Lines</a></li>
          
            
            

            
            

            <li><a href="introduction-unicode.html" class="">Introduction to Unicode</a></li>
          
            
            

            
            

            <li><a href="unicode-text-processing.html" class="">Unicode Text Processing</a></li>
          
            
            

            
            

            <li><a href="transparent-text.html" class="">Transparent Text</a></li>
          
            
            

            
            

            <li><a href="introduction-uniscribe.html" class="">Introduction to Uniscribe</a></li>
          
            
            

            
            

            <li><a href="uniscribe-mysteries.html" class="">Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="more-uniscribe-mysteries.html" class="">More Uniscribe Mysteries</a></li>
          
            
            

            
            

            <li><a href="drawing-styled-text-uniscribe.html" class="">Drawing styled text with Uniscribe</a></li>
          
            
            

            
            

            <li><a href="integrating-usplib.html" class="">Integrating UspLib</a></li>
          
            
            

            
            

            <li><a href="keyboard-navigation.html" class="">Keyboard Navigation</a></li>
          
            
            

            
            

            <li><a href="piece-chains.html" class="active">Piece Chains</a></li>
          
            
            

            
            

            <li><a href="unicode-text-editing.html" class="">Unicode Text Editing</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>
    

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Piece Chains">
    <meta itemprop="description" content="OK so I lied about getting the syntax-highlighting implemented this time around. I got bogged down in “regular expression hell” and needed something else to concentrate on. So during the summer period I’ve instead been slowly implementing Neatpad’s text-editing capability. As I hinted at in the very first installment of this tutorial series, I have decided to follow the “Piece Table” design. The aim of this tutorial will be to discuss the rationale behind this decision and also highlight some (but not all) of the implementation details. Note that I will not be discussing issues related to the editing of Unicode text (this will come in the next tutorial). Instead we will look at the design of the piece-table from a low-level perspective, independent of any Unicode concerns.">
    <meta itemprop="datePublished" content="September 12, 2006">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Piece Chains
</h1>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <!--h1>Piece Chains</h1-->
<!--h3>Editing text with Piece Chains</h3-->

<p>OK so I lied about getting the syntax-highlighting implemented this time around. I got bogged down in “regular expression hell” and needed something else to concentrate on. So during the summer period I’ve instead been slowly implementing Neatpad’s text-editing capability. As I hinted at in the very first installment of this tutorial series, I have decided to follow the “Piece Table” design. The aim of this tutorial will be to discuss the rationale behind this decision and also highlight some (but not all) of the implementation details. Note that I will <em>not</em> be discussing issues related to the editing of Unicode text (this will come in the next tutorial). Instead we will look at the design of the piece-table from a low-level perspective, independent of any Unicode concerns.</p>

<p>Several years ago when I started writing HexEdit there was very little information I could find regarding editor design. Google was unheard of and AltaVista was the search-engine of choice. I had a 33k dial-up modem and the single resource I stumbled over at the time was a paper written by a University professor named Charles Crowley. His paper ‘<a href="../../zips/crowley.zip">Data Structures for Text Sequences</a>’ and the ‘Piece Table’ approach he described heavily influenced the design of HexEdit, making it one of the slickest hex-editors available. I later documented HexEdit’s piece-table design (or span-table, as I called it then) in my ‘<a href="../../bigmem02.asp">Memory Management for Large File Editors</a>’ article. Today there seems to be a little more information available regarding Piece-Tables - and certainly more evidence of people using this design in their projects:</p>

<ul>
  <li><a href="../../../www.abisource.com/index.html">AbiWord</a> is an extremely impressive cross-platform, open-source word processing package. Some of the authors maintain blogs in which they have discussed aspects of AbiWord’s design. Of particular note is the discussion regarding <a href="../../../e98cuenc.free.fr/wordprocessor/piecetable.html">AbiWord’s Piece Table design</a>, in which the author details the transition to a ‘red-black’ binary tree representation of the piece-table.</li>
  <li><a href="../../../www.winasm.net/index.html">WinAsm Studio</a> is an IDE for assembly-language programming. Antonis Kyprianou (the author) is also writing a ‘piece-table’ based editor for inclusion within the IDE.</li>
  <li><a href="../../../www.chiark.greenend.org.uk/%7Esgtatham/tweak/index.html">Tweak</a> is a terminal-based Unix hex-editor. According to the <a href="../../../www.chiark.greenend.org.uk/%7Esgtatham/tweak/btree.html">website description</a> tweak uses a binary tree data structure to represent edits to the file. The article is well worth a read and there is some very interesting information available there.</li>
  <li><a href="../../../www.sgi.com/tech/stl/Rope.html">C++ Rope class</a> looks to be quite interesting. I know almost nothing about it, other than what is described on that page. The description seems to indicate that the rope-class is using a piece-table implementation but I don’t know this for sure.</li>
</ul>

<p>Piece-tables are not a new development by any means and have been around for several years in one form or another:</p>

<ul>
  <li><a href="../../../en.wikipedia.org/wiki/Xerox_PARC.html">Xerox PARC</a> (Palo Alto Research Center) produced the <strong>Bravo text editor</strong> in the 1970s. Bravo was the work of Charles Simonyi and Butler Lampson, and used a “Piece Chain” to implement it’s editing functionality. Unfortunately the <a href="../../../en.wikipedia.org/wiki/Xerox_Alto.html">Alto</a> platform (on which Bravo ran) is now so old that information on the Bravo editor does not appear to be available any more. Maybe the <a href="../../../altogether.brouhaha.com/index.html">Altogether</a> project (an Alto emulator) will get off the ground and we can re-explore these old computer systems.</li>
  <li>
    <p><a href="../../../en.wikipedia.org/wiki/Oberon_operating_system.html">Project Oberon</a> is an operating system, compiler and programming language. The classic computer-science book ‘Project Oberon’ is available in PDF format <a href="../../../www.oberon.ethz.ch/books.html">here</a> and details the design of the Oberon platform. The book has a very interesting chapter on text-management, in which the piece-chain technique is described in great detail.</p>
  </li>
  <li><strong>Mutable Text</strong> is a <a href="../../../en.wikipedia.org/wiki/Modula-3.html">Modula-3</a> interface for editing text streams. <strong>MText</strong> implements a piece-table design using a balanced binary tree for efficiency. The only information I could gather on the MText interface was from Compaq’s old research website. Because Compaq no longer exist (HP bought them) I had to use Google-Cache to find this information.</li>
</ul>

<p>Obviously the piece-chain technique has been around for over 30 years now, with the first notable occurance with the Bravo editor. The surprising thing is that this technique is still quite rare even today.</p>

<h2 id="the-perfect-text-editor">The Perfect Text Editor</h2>

<p>Of course, there is no such thing as the perfect text editor - otherwise we would all be using the same tool and I wouldn’t be writing this article-series in a (likely futile) attempt to create <em>my</em> vision of a perfect editor.</p>

<p>Even if we ignore the overwhelming differences between editor’s user-interface design, there is still a great diversity in editor <em>implementation</em>. What I mean by this, is that there is no single ‘true’ design that all text editors follow. Instead many distinct methods exist - such as the buffer-gap scheme, linked-lists of lines, and the somewhat rarer piece-chain techniques - all of which have been used with varying degrees of success over the years.</p>

<p>One of the reasons the piece-chain method is not very common is the complexity of it’s implementation for text editors. It is not the actual piece-management that is difficult, but rather the maintanence of the editor’s line-buffers that becomes troublesome. For this reason many editors choose not to implement piece-chains - and mature editors such as Vi and Emacs can be seen to be very successful without this design.</p>

<p>The fact that all of these techniques exist is a strong indication that there is no overwhelming ‘best’ design for text-editors. I don’t know at this stage if I am making the right decision by implementing piece-tables for Neatpad. However I am determined to complete this project, and at the very least I will know one way or another, if the piece-table design is suitable for a plain-text editor.</p>

<h2 id="piece-chains-with-linked-lists">Piece Chains with Linked Lists</h2>

<p>Neatpad implements it’s piece-chain data structure using a doubly-linked list, which closely follows the original design of <a href="../../software/hexedit.asp">HexEdit</a>. Whilst other structures such as binary-trees could be used, a linked-list is preferred for it’s simplicity. The original design for HexEdit maintained a <em>Head</em> and <em>Tail</em> pointer for representing the start and end of the piece-chain. Most people should be familiar with this concept; if you aren’t then I would suggest reading up on this subject before going any further. Anyway, the classic doubly-linked list (which I used in HexEdit) is illustrated below:</p>

<p><img src="assets/img/editor1712.gif" alt="" class="align-center" /></p>

<p>The snippet below further illustrates how such a linked-list might be initialized:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sequence constructor
</span><span class="n">sequence</span><span class="o">::</span><span class="n">sequence</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The small problem with this design is the way the head and tail pointers are managed. Whenever a node is inserted at the front or back of the list, specific code is required to handle these ‘special case’ conditions because the head or tail pointers need updating to point to the new nodes. Link management is cumbersome and over-complicates sequence manipulations a great deal.</p>

<p>An alternative design is to maintain what are termed ‘sentinel’ nodes. In this model, two <em>dummy</em> nodes are introduced at the start and end of the list. Their contents are not defined (lengths will be zero), but their very presence means that every node in the list is guaranteed to have a valid neighbour. In other words, apart from the sentinels themselves, every node’s <em>next</em> and <em>previous</em> link always point to a valid node. This essentially removes any ‘special case’ code for dealing with insertions or deletions at the start and end of the list.</p>

<p><img src="assets/img/editor1713.gif" alt="Linked-list with sentinel nodes" class="align-center" />
<em class="align-center">Linked-list with sentinel nodes.</em></p>

<p>To further illustrate, an empty list contains just two nodes; the head and tail sentinels, which simply point to each other.</p>

<p><img src="assets/img/editor1714.gif" alt="Empty List" class="align-center" />
<em class="align-center">Empty list.</em></p>

<p>Supporting this linked-list design is very simple. Instead of initializing the head and tail pointers to NULL, two ‘empty’ nodes are created which link between each other. Any nodes that are subsequently added are inserted in-between the sentinels.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sequence</span><span class="o">::</span><span class="n">sequence</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">tail</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is surprising how much work this simple idea saves. Of course I can’t claim credit for this method - I originally read about this trick in one of Michael Abrash’s assembly-optimization books many years ago.</p>

<h2 id="spans-and-pieces">Spans and Pieces</h2>

<p>The term <em>piece-chain</em> is nice and succinct, because one can straight away imagine the pieces of text being chained together within the data structure. However I use the term <em>span</em> in Neatpad to represent each piece of text in the chain, purely because this is how I did things in HexEdit. There is no difference between a <em>piece</em> and a <em>span</em> apart from the name - they both serve the same purpose.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// span - private to the sequence
</span><span class="k">struct</span> <span class="n">span</span>
<span class="p">{</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">prev</span><span class="p">;</span>

    <span class="n">size_w</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">size_w</span> <span class="n">length</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The piece-table is formed by chaining together the <code class="highlighter-rouge">span</code> objects through their <code class="highlighter-rouge">next</code> and <code class="highlighter-rouge">prev</code> links. The linked-list is maintained by a <code class="highlighter-rouge">sequence</code> C++ class, which encapsulates the entire data structure inside a single object. The <code class="highlighter-rouge">insert</code>, <code class="highlighter-rouge">replace</code> and <code class="highlighter-rouge">erase</code> functions are included to provide the editing interface:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// define the type of strings the sequence will hold
</span><span class="k">typedef</span> <span class="kt">wchar_t</span> <span class="n">seqchar</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">sequence</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">insert</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">seqchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">replace</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">seqchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">erase</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">undo</span> <span class="p">();</span>
    <span class="kt">bool</span> <span class="n">redo</span> <span class="p">();</span>

    <span class="c1">// other members snipped
</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">head</span><span class="p">;</span> <span class="c1">// pointers to list sentinels
</span>    <span class="n">span</span> <span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The central idea behind <em>spans</em> is that they provide a level of indirection to the underlying file contents. The individual nodes never store any text - they only refer to ranges of text stored in the original file, or to any range of text in the modify-buffer added due to text insertions. You can see from the definition above that a span has no means for storing text - instead the <code class="highlighter-rouge">offset, length</code> and <code class="highlighter-rouge">buffer</code> fields identify a range (or <em>piece</em>) of text in the original file.</p>

<p>The image below illustrates a typical piece-chain organisation. The ‘original file’ buffer is initialized with the text “The brown fox jumped over the lazy dog”. The single word “ing” has been inserted into the sequence - with this text appended to the modify buffer. The spans in the piece-chain form the sequence “The jumping dog”.</p>

<p><img src="assets/img/editor1716.gif" alt="&lt;&gt;" class="align-center" /></p>

<p>An important thing to note is that spans have no knowledge of their <em>logical</em> position in the sequence. They only know the physical location of the data they reference. This has the advantage that new spans can be inserted or deleted from the piece-chain with no effect on the other spans in the list. This is why inserting and deleting from a piece-table is so fast - assuming that you know <em>where</em> to insert.</p>

<p>The flexibility of the piece-table’s is also it’s biggest drawback. Because spans don’t know their logical position there is no way to directly access a specific text-offset within the document. All accesses must go through the linked-list by starting at the head of the list. Any time we want to locate a specific character-offset we must iterate through each span in turn, summing their <em>lengths</em> in order to keep track of the current logical position:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">span</span> <span class="o">*</span> <span class="n">sequence</span><span class="o">::</span><span class="n">spanfromindex</span> <span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">size_w</span> <span class="o">*</span><span class="n">spanindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">span</span> <span class="o">*</span><span class="n">sptr</span><span class="p">;</span>
    <span class="n">size_w</span> <span class="n">curidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// scan the list looking for the span which holds the specified index
</span>    <span class="k">for</span><span class="p">(</span><span class="n">sptr</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">sptr</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">curidx</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">curidx</span> <span class="o">+</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">spanindex</span><span class="p">)</span> 
                <span class="o">*</span><span class="n">spanindex</span> <span class="o">=</span> <span class="n">spanidx</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">sptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">spanidx</span> <span class="o">+=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// insert at tail?
</span>    <span class="k">if</span><span class="p">(</span><span class="n">sptr</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="n">curidx</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">spanindex</span> <span class="o">=</span> <span class="n">curidx</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">sptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">spanfromindex</code> function above shows how the piece-chain is traversed from the start in order to locate the span. The lengths of each span are summed together until the correct node is found. The simplicity of a linked-list design is also it’s biggest drawback - random access to a linked list is slow.</p>

<h2 id="unlimited-undo--redo">Unlimited Undo &amp; Redo</h2>

<p>In theory unlimited undo+redo is incredibly simple with piece-tables. In fact it is almost ‘free’. This is one reason why this technique is so desirable - the big selling point for me is that the piece-chain is (in computer-science terms) a <a href="../../../en.wikipedia.org/wiki/Persistent_data_structure.html">Persistent Data Structure.</a> In essence this means that the piece-chain preserves older versions of itself even when modified. Most importantly these older versions are easily restorable whilst still maintaining the integrity of the data-structure.</p>

<p>It is important to remember that the underlying data in the file we are editing never changes - it is only the linked-list nodes (the <em>spans</em>) that change, in order to represent modifications to the file. Therefore there is no need to maintain separate data-buffers containing the document contents which have been modified. The memory-savings the piece-chain brings are significant enough to warrant the added complexity this method.</p>

<p>The key to Neatpad’s implementation of undo/redo is the use of <em>span-ranges</em>. Quite simply, a <em>span-range</em> is an object which represents a contiguous range of spans within the sequence. Any time the piece-chain is manipulated, a span-range object is pushed onto the undo stack which represents the range of spans affected by the edit.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">span_range</span>
<span class="p">{</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">span</span> <span class="o">*</span> <span class="n">last</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">boundary</span><span class="p">;</span>
    <span class="n">size_w</span> <span class="n">sequence_length</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Each <em>span-range</em> is therefore used to represent a single modification to the sequence. The <code class="highlighter-rouge">first</code> and <code class="highlighter-rouge">last</code> fields point to the range of spans that encompass a particular edit operation. All spans in the range are linked together internally using their regular <em>next</em> and <em>prev</em> pointers. Now whilst a span-range can conceptually hold multiple spans all chained together, it can also reference a single span by pointing both <code class="highlighter-rouge">first</code> and <code class="highlighter-rouge">last</code> to the same span.</p>

<p>Notice how the sequence-length is stored inside each span-range. This is necessary because we don’t want to re-calculate the sequence-length each time we undo or redo an action (doing so would be very slow for large piece-chains). By preserving the sequence-length prior to editing the sequence we can easily restore this value when we undo.</p>

<p>Span <em>boundaries</em> are a special form of span-range. Think of a span-boundary as the <em>gap</em> between two adjacent spans. A span-range is still used to represent this form of ‘empty’ range, with its <code class="highlighter-rouge">boundary</code> field set to ‘true’ to indicate what kind of range it is.</p>

<p><img src="assets/img/editor1715.gif" alt="" class="align-center" /></p>

<p>The image above illustrates both kinds of span-range. The range on the left is a ‘regular’ range, with <code class="highlighter-rouge">boundary</code> set to <em>false</em>. The range on the right is an ‘empty’ range, and the span-range object has it’s <code class="highlighter-rouge">boundary</code> field set to <em>true</em>.</p>

<p>In actual fact span-ranges are used for more than just holding history - they are also used as auxiliary helper objects when manipulating spans during insert and erase operations. They are just a convenient way to store sections of the piece-chain as they are moved in and out of the sequence.</p>

<h2 id="inserting-data">Inserting Data</h2>

<p>Data insertion is by far the simplest to implement. There are two basic scenarios that we need to consider - inserting in the middle of a span, and inserting at a span boundary. As we look at these operations in more detail, remember that edits to the text-sequence are just modifications to the spans in the list. <strong>Note</strong> that in all of these examples, the text is shown to be contained within each span. This is for illustrative purposes only - because we know that in reality the spans do not hold any text, rather they refer to ranges of text in the <em>original</em> or <em>modify</em> buffers. In addition the head and tail <em>sentinel</em> nodes are also shown - as the grey blocks at either end of the list.</p>

<p>Inserting in the <strong>middle</strong> of a span is the first scenario. We start with the piece-chain in the following state:</p>

<p><img src="assets/img/editor1706.gif" alt="" class="align-center" /></p>

<p>The sequence holds the text “TheQuickBrown” and for whatever reason the linked-list holds three spans. Our first example will be to insert the string “xxxx” at index “6”. This position in the sequence happens to fall in the middle of the second span.</p>

<p><img src="assets/img/editor1707.gif" alt="" class="align-center" /></p>

<p>Inserting in the middle of a span requires that the span be split into two separate pieces - which represent the data before and after the insertion point. A third span is linked in-between these two new pieces which will represent the actual inserted data. As expected the inserted data is appended to the ‘modify buffer’ which leaves the original file-buffer untouched.</p>

<p><img src="assets/img/editor1704.gif" alt="" class="align-center" /></p>

<p>Although we have conceptually split a span in half in order to represent an ‘insertion’, in reality we do not do this. If you study the piece-chain you can see that the span representing the word ‘Quick’ has been removed from the sequence, to be replaced with three new spans. However rather than deleting this span we instead preserve it, by holding it inside a span-range object. This span-range is then pushed onto our ‘undo stack’ in order to represent the range of spans that were modified by the insertion.</p>

<p>This strategy of span preservation is key in this implementation of a <em>persistant data structure</em>. Notice that after the insertion has taken place, no spans in the piece-chain reference the “Quick” span anymore. However “Quick” still maintains it’s own links back into the main list. This is a very important detail, because when it comes to restoring the sequence (undoing this last action) we need to know where-abouts in the list the spans on the undo-stack should be re-inserted.</p>

<p>Shown below is the basic outline for how data is inserted for this first scenario, taken from the <code class="highlighter-rouge">sequence::insert</code> function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// initialize a new 'undo'. It will be pushed onto the undo-stack.
</span><span class="n">span_range</span> <span class="o">*</span><span class="n">oldspans</span> <span class="o">=</span> <span class="n">init_undo</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">action_insert</span><span class="p">);</span>
<span class="n">span_range</span> <span class="n">newspans</span><span class="p">;</span>

<span class="c1">// preserve the span that we are inserting into
</span><span class="n">oldspans</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">sptr</span><span class="p">);</span>

<span class="c1">// new spans for before and after the insertion point
</span><span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">insoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>
<span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">modbuf_offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">modifybuffer_id</span><span class="p">));</span>
<span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">+</span><span class="n">insoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="n">insoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>

<span class="c1">// insert the new pieces into the sequence!!
</span><span class="n">swap_spanrange</span><span class="p">(</span><span class="n">oldspans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newspans</span><span class="p">);</span>
<span class="n">sequence_length</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
</code></pre></div></div>

<p>All sequence-modifications in Neatpad follow the same basic pattern:</p>

<ol>
  <li>Spans to be removed from the sequence are stored inside an “oldspans” span-range.</li>
  <li>Spans to be introduced into the sequence are stored inside a “newspans” span-range.</li>
  <li>The “oldspans” are pushed onto the undo-stack.</li>
  <li>The two span-ranges are then swapped around.</li>
</ol>

<p>Inserting at a <strong>span boundary</strong> is the next scenario to consider. In this example the two-letter string “yy” will be inserted at sequence-position “6” again, which now falls between “Qui” and the “xxxx” span we inserted previously.</p>

<p><img src="assets/img/editor1708.gif" alt="" class="align-center" /></p>

<p>This time a single span is inserted into the list, in-between the “Qui” and “xxxx” nodes. The undo-event which represents this action is a span-range holding the spans either side of the insertion-boundary. This ‘span boundary’ is distinguised by the ‘*’ symbol. Notice how these spans again maintain their links back into the linked-list.</p>

<p><img src="assets/img/editor1705.gif" alt="" class="align-center" /></p>

<p>Another important detail to notice is how the undo-stack has grown with the new span-range pushed onto it. Hopefully you can see how multi-level undo would be implemented: Each time we edit the sequence we push another span-range onto the undo-stack. Each entry in this stack represents the range of spans affected by that particular edit operation. Every time we perform an “undo” a span-range is “popped” from the undo-stack and re-inserted back into the main linked-list. The spans that it replaces are removed, but still preserve their own links back into the list. Each span-range that is removed during an undo is pushed onto a <em>redo stack</em>.</p>

<p>The code for span-boundary-insertion is much simpler because only one span is inserted this time:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// initialize a new 'undo' 
</span><span class="n">span_range</span> <span class="o">*</span><span class="n">oldspans</span> <span class="o">=</span> <span class="n">init_undo</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">action_insert</span><span class="p">);</span>
<span class="n">span_range</span> <span class="n">newspans</span><span class="p">;</span>

<span class="c1">// this is a 'boundary insertion' 
</span><span class="n">oldspans</span><span class="o">-&gt;</span><span class="n">spanboundary</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">sptr</span><span class="p">);</span>

<span class="c1">// single span for the inserted data
</span><span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">modbuf_offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">modifybuffer_id</span><span class="p">));</span>

<span class="c1">// insert the new span into the sequence in place of the old ones
</span><span class="n">swap_spanrange</span><span class="p">(</span><span class="n">oldspans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newspans</span><span class="p">);</span>
<span class="n">sequence_length</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
</code></pre></div></div>

<p>The code follows the same pattern as before: define the ‘oldspans’, collect together the ‘newspans’ and then swap them around. The only difference this time is how the ‘oldspans’ are defined. No spans were modified in the boundary-insertion case so the span-range represents a span-boundary by pointing to the spans <em>either side</em> of the boundary we inserted at.</p>

<h2 id="erasing-data">Erasing Data</h2>

<p>Erasing data from the sequence is rather more complicated. In fact, it is a lot more complicated. The problem is that deletions can potentially encompass several spans, and can start and stop mid-span as well. Here are the scenarios that must be catered for:</p>

<ul>
  <li>Erase starts at a span boundary.</li>
  <li>Erase starts mid-way through a span (in which case the span must be split).</li>
  <li>Erase stops at a span-node boundary.</li>
  <li>Erase stops mid-way through a span (again the span should be split).</li>
</ul>

<p>We must also consider the case where a deletion can encompass several spans. All four scenarios above must be taken into account in this case. There is also the case were a deletion is contained entirely within a single span. Again, boundary or mid-span conditions must be taken into account.</p>

<p>The mistake I made with HexEdit’s piece-chain implementation was to handle all of these cases separately which resulted in hugely over-complicated code. What I should have done, and what I have done this time around, is have one ‘general-case’ that handles all scenarios:</p>

<p><img src="assets/img/editor1710.gif" alt="" class="align-center" /></p>

<p>The example above shows a deletion which encompasses several spans, and both starts and stops mid-way through a span as well.</p>

<p><img src="assets/img/editor1711.gif" alt="" class="align-center" /></p>

<p>Because the deletion affected every span in the list, the entire linked-list has been pushed onto the undo-stack in the form of a span-range, to be replaced with just two new spans that represent the data before and after the deleted range.</p>

<p>The code starts by checking to see if the deletion starts mid-way through a span. If it does, that span is added to the <code class="highlighter-rouge">oldspans</code> span-range, and a replacement span created which represents the data in the span just before the deletion-index. This ‘split’ span is added to the <code class="highlighter-rouge">newspans</code> range:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// does the deletion *start* mid-way through a span?
</span><span class="k">if</span><span class="p">(</span><span class="n">remoffset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// split the span - keep the first "half"
</span>    <span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">remoffset</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">));</span>

    <span class="c1">// have we split a single span into two?
</span>    <span class="c1">// i.e. the deletion is completely within a single span
</span>    <span class="k">if</span><span class="p">(</span><span class="n">remoffset</span> <span class="o">+</span> <span class="n">removelen</span> <span class="o">&lt;</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// make a second span for the second half of the split
</span>        <span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span>
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">remoffset</span> <span class="o">+</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">remoffset</span> <span class="o">-</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
            <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">removelen</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">removelen</span><span class="p">,</span> <span class="p">(</span><span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">remoffset</span><span class="p">));</span>

    <span class="c1">// archive the span we are going to delete
</span>    <span class="n">oldspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sptr</span><span class="p">);</span>
    <span class="n">sptr</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	
<span class="p">}</span>
</code></pre></div></div>

<p>Once this first scenario has been handled, a loop is used to process any further spans until we reach the end of the deletion-range. Every node that falls under the ‘delete range’ is appended to the <code class="highlighter-rouge">oldspans</code> container object. A special-case is used to handle the scenario when a delete stops mid-way through a span.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// we are now on a proper span boundary, so remove
// any further spans that the erase-range encompasses
</span><span class="k">while</span><span class="p">(</span><span class="n">removelen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sptr</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// will the entire span be removed?
</span>    <span class="k">if</span><span class="p">(</span><span class="n">removelen</span> <span class="o">&lt;</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// split the span, keeping the last "half"
</span>        <span class="n">newspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="k">new</span> <span class="n">span</span><span class="p">(</span>
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">removelen</span><span class="p">,</span> 
            <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
            <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">removelen</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">removelen</span><span class="p">,</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

    <span class="c1">// archive the span we are replacing
</span>    <span class="n">oldspans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sptr</span><span class="p">);</span>
    <span class="n">sptr</span> <span class="o">=</span> <span class="n">sptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The very last thing to do is swap out the ‘oldspans’ with the ‘newspans’ and update the sequence-length:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">swap_spanrange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldspans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newspans</span><span class="p">);</span>
 <span class="n">sequence_length</span> <span class="o">-=</span> <span class="n">length</span><span class="p">;</span>
</code></pre></div></div>

<p>All of this code can be found in the <code class="highlighter-rouge">sequence::erase</code> member function, but is a lot more complicated than what I have shown here. In particular there are special-cases for ‘optimized’ deletes which almost doubles the amount of code required. I have no intention of detailing this process any further, just look at the sourcecode download of you are interested.</p>

<h2 id="replacing-data-overwriting">Replacing Data (overwriting)</h2>

<p>Data-replacement is the most complex operation to implement, and should be thought of as a hybrid form of <em>erase</em> and <em>insert,</em> combined into a single function. All of the complexities of these first two operations must be taken into account when implementing <code class="highlighter-rouge">sequence::replace</code>. In addition the ‘optimized replace’ scenario - in which multiple, consecutive replaces are coalesced into a single operation - makes <code class="highlighter-rouge">replace</code> very complicated indeed. I am not going to go into any great detail - suffice to say, the sourcecode download contains everything you need to know.</p>

<p>When I originally wrote HexEdit’s sequence class, yet another mistake I made was to write a separate routine for replacing data in the sequence. I took the already overcomplicated ‘erase’ function and duplicated the code into a new ‘replace’ function. I then merged in the code for inserting data which made it even more complicated. This made code-maintanence very difficult because of the code-duplication problems.</p>

<p>I didn’t make the same mistake second time around. Neatpad’s <code class="highlighter-rouge">sequence::replace</code> function is simply a wrapper around <code class="highlighter-rouge">sequence::erase</code> and <code class="highlighter-rouge">sequence::insert</code>. First of all <code class="highlighter-rouge">erase</code> is called to delete the range of data that will be replaced. This temporarily shortens the sequence. Next, <code class="highlighter-rouge">insert</code> is called with the ‘replace’ data which is inserted into the place where the delete occured, re-growing the sequence back to it’s original length. Importantly, these two actions are <em>grouped</em> together so that they appear as a single undoable action.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">sequence</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="n">size_w</span> <span class="n">index</span><span class="p">,</span> <span class="n">seqchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size_w</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">group</span><span class="p">();</span>
    <span class="n">erase</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">ungroup</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Writing <code class="highlighter-rouge">sequence::replace</code> this way significantly simplified the sequence’s implementation. It wasn’t quite as straight-forward as I make out because of the problem of ‘optimized replaces’ - the <code class="highlighter-rouge">sequence::erase</code> function must have a small amount of logic to cater for ‘regular erases’ vs ‘replace erases’. But in general I found this ‘shortcut’ far more preferable to what I had done before. Importantly, any time I have to change the <code class="highlighter-rouge">erase</code> or <code class="highlighter-rouge">insert</code> functions (because of a bug for example) I don’t have to modify the <code class="highlighter-rouge">replace</code> function in parallel - it gets all changes for free because it’s just a simple wrapper function.</p>

<h2 id="piece-chain-demo-application">Piece-chain demo application</h2>

<p>Testing a piece-chain implementation is rather difficult because of all the subtle scenarios that can occur. I started off with a simple console application in which I would type “insert <em>index text</em>”’ or “erase <em>index length</em>”. It was rather cumbersome so I took the UspLib Demo application which I wrote for a previous tutorial, and came up with the “Piece Chain Demo”:</p>

<p><img src="assets/img/editor1717.gif" alt="" class="align-center" /></p>

<p>I found this form of test-harness very useful as it gives instant feedback as to the state of the piece-chain after each operation. It also shows the contents of the Original File, Modify-Buffer, and also the Undo stacks. It’s not so useful now that I have integrated the piece-chain into Neatpad, but at the very least it might be interesting to anyone who is attempting to learn more about piece-chains. <a href="../../zips/piecechain.zip">Give it a whirl</a>!</p>

<h2 id="linked-lists-vs-binary-trees">Linked Lists vs Binary Trees</h2>

<p>There is some debate as to how a piece-table should be represented. The two main choices are either a linked-list, or some form of binary tree. For the time-being Neatpad uses a doubly-linked list to manage it’s piece-table. This method has been proven to be effective in my HexEdit application, but it remains to be seen whether or not a linked-list is suitable for a text editor:</p>

<p><strong>Linked lists</strong> are very simple to manipulate and traverse. However locating a specific character-position can be potentially very slow if there are a large number of nodes in the list, because the list must be traversed from it’s start any time a particular node is required. Caching can solve most of the linked-list’s speed problems, because the majority of operations on the sequence will be very localized (you can only type within a fixed viewport of the document at any one time). Caching the last-accessed span can yield large improvements here.</p>

<p><strong>Binary trees</strong> on the other hand are the exact opposite. A <em>balanced</em> binary tree is great for searching but bad for inserting/modifying. Searching is always O(log N), so locating a specific character-position is always fairly fast, even for a sequence that holds many thousands of nodes. However manipulating a binary-tree is always fairly <em>expensive</em> compared to the linked-list. Any time a node is inserted into a binary-tree, the tree must be rebalanced, and all children of that node must be updated to reflect the change.</p>

<p>In both cases the complexity of the data-structure we choose (the number of spans it contains) is a function of the number of <em>edits</em> to the file and is not at all related to the size of the file or the number of lines it contains. This makes the piece-chain a great data structure because it scales very well, even for very large files. It is far preferable to a “linked list of lines” model, which does not scale well for large files. The piece-table is definitely the data structure of choice in my opinion.</p>

<p>If we were concerned purely with edits to the piece-table, I believe the linked-list is the superior choice. Should we need to use the data-structure as a way to perform other kind of searches (such as looking up line-numbers, or mapping line-numbers to character-offsets) then this might require a move to a binary-tree implementation.</p>

<h2 id="c-templates-and-vs2005">C++ templates and VS2005</h2>

<p>For the moment I have resisted the temptation to implement the <code class="highlighter-rouge">sequence</code> class using C++ templates. This is primarily due to the poor template support in VC6.0, but I also wanted to make the initial version ‘clean’ enough for non-C++ programmers to understand. Currently the <code class="highlighter-rouge">sequence</code> class uses a hard-coded <code class="highlighter-rouge">'seqchar'</code> datatype as it’s basic unit of text, which is currently a 16bit WCHAR type. It is simple to re-target the sequence to any other character type by simply changing the <code class="highlighter-rouge">typedef</code> statement at the top of <code class="highlighter-rouge">sequence.h</code>, so for the time-being templates would be a luxury rather than a necessity.</p>

<p>However I have recently started using VS2005 and now have the opportunity to take advantage of a <em>much</em> better C++ compiler. If I do migrate to VS2005 it will make it harder to compile Neatpad under VC6.0 because the projects will be incompatible. And if I change the sequence-class to a template implementation, Neatpad won’t compile under VC6.0 at all. What do people think about this proposal? If I get no comments I’ll go ahead and migrate to VS2005…</p>

<h2 id="conclusion">Conclusion</h2>

<p>I have deliberately tried to keep the piece-chain implementation as simple as possible. I see no need at this stage to migrate to a binary-tree implementation for the piece-chain, although future tutorials may have to address this issue if performance becomes a problem. The important thing is, it doesn’t really matter if we use a list or a tree - everything is encapsulated inside the <code class="highlighter-rouge">sequence</code> C++ class so changing to a binary-tree would have no real impact on the rest of the design.</p>

<p>Piece-tables are actually a very simple concept and are <em>not</em> as complicated as they may seem from this article. The complexities arise from the way the piece-chain is <em>optimized</em> each time an edit occurs. Consecutive inserts, erases and replaces are coalesced in such a way that the number of spans in the list is always at a minimum. This requires that individual span’s be adjusted ‘in place’ rather than introducing new spans into the table each time an edit occurs. This also complicates the undo/redo support as well. Without this optimization piece-chains are very simple, but unfortunatey a ‘real world’ piece-chain must have these features if it is to be successful.</p>

<p>The next tutorial will focus on how I integrated the piece-chain design into Neatpad. There are a lot of issues to discuss, mainly due to the subtleties of editing Unicode text. I also need to implement proper ‘memory management’ and large-file support - this will be covered in a later tutorial as well.</p>



  <div class="file-attachments">
    <h4>DOWNLOADS</h4>
    
      
       <a href="assets/files/piecechain.zip">piecechain.zip</a>      
    
  </div>

        
      </section>

      <footer class="page__meta">
        
        


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2006-09-12T00:00:00+00:00">September 12, 2006</time></p>
        
      </footer>

      

      
  <nav class="pagination">
    
      <a href="../../tuts/win32/tips-and-tricks-part-2.html" class="pagination--pager" title="Win32 Tips &amp; Tricks - Part 2
">Previous</a>
    
    
      <a href="unicode-text-editing.html" class="pagination--pager" title="Unicode Text Editing
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    <li><a href="../../feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2019 Catch22. Powered by <a href="https://jekyllrb.com/index.html" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/index.html" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="assets/js/main.min.js"></script>
  <script defer src="https://use.fontawesome.com/releases/v5.6.0/js/all.js" integrity="sha384-z9ZOvGHHo21RqN5De4rfJMoAxYpaVoiYhuJXPyVmSs8yn20IE3PmBM534CffwSJI" crossorigin="anonymous"></script>








  </body>
</html>
